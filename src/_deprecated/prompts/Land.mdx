LAND PHASE — Ticket: {props.ticketId}

Title: {props.ticketTitle}
Category: {props.ticketCategory}
Branch: ticket/{props.ticketId}

## Your Task

Land the ticket branch onto main using jj. You are running in the MAIN repo (not a worktree).

### Step 1: Fetch latest main

```
jj git fetch
```

### Step 2: Review what landed on main since you branched

Before rebasing, check what other tickets landed on main since this branch diverged. This helps you catch **semantic conflicts** (code that doesn't cause git conflicts but breaks at runtime — e.g. renamed functions, changed signatures, moved files, altered behavior your code depends on).

```
jj log -r 'main..bookmark("ticket/{props.ticketId}")' --reversed
jj diff -r 'roots(main..bookmark("ticket/{props.ticketId}"))' --summary
```

Review the log and diff carefully. If other tickets modified files or APIs that your branch also touches, check for:
- Functions/methods that were renamed, moved, or had signatures changed
- Shared constants or config values that were altered
- Test helpers or fixtures that were restructured
- Database schema changes that affect your queries
- Import paths that changed due to refactoring

### Step 3: Rebase branch onto latest main

```
jj rebase -b 'bookmark("ticket/{props.ticketId}") ' -d main
```

If there are explicit conflicts, resolve them and describe the resolution.

If you identified potential semantic conflicts in Step 2, verify after rebase that:
- All imports still resolve
- Function calls use correct signatures
- Tests reference the right helpers/fixtures

### Step 4: Run final CI

Run all verification commands:
{props.ciCommands && props.ciCommands.length > 0
  ? props.ciCommands.map(c => `- \`${c}\``).join('\n')
  : '- `go test ./...`\n- `make sqlc`'}

If CI fails, output `{ "merged": false, "mergeCommit": null, "ciPassed": false, "summary": "..." }` with details of the failure.

### Step 5: Fast-forward main

If CI passes:
```
jj bookmark set main -r 'bookmark("ticket/{props.ticketId}")'
```

### Step 6: Push main

```
jj git push --bookmark main
```

### Step 7: Cleanup branch

```
jj bookmark delete ticket/{props.ticketId}
```

### Step 8: Get the merge commit hash

```
jj log -r main --no-graph -T commit_id
```

## Output

Output the result as JSON:
- If successful: `{ "merged": true, "mergeCommit": "<commit hash>", "ciPassed": true, "summary": "..." }`
- If failed: `{ "merged": false, "mergeCommit": null, "ciPassed": false, "summary": "..." }`

The Ralph loop will retry failed landings on the next iteration.
