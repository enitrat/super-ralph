IMPLEMENTATION PHASE — Ticket: {props.ticketId}

Title: {props.ticketTitle}
Category: {props.ticketCategory}

## Context

Read the plan file: {props.planFilePath}
Read the context file: {props.contextFilePath}

Implementation steps from plan:
{props.implementationSteps ? props.implementationSteps.map((s, i) => `${i + 1}. ${s}`).join('\n') : 'See plan file'}

{props.previousImplementation ? `\nPrevious implementation attempt:\nWhat was done: ${props.previousImplementation.whatWasDone}\nNext steps: ${props.previousImplementation.nextSteps ?? 'None specified'}` : ''}
{props.evictionContext ? `\nMerge queue eviction context from prior landing attempt (address this explicitly):\n${props.evictionContext}` : ''}

{props.reviewFeedback ? `\nReview feedback to address:\n${props.reviewFeedback}` : ''}

{props.failingTests ? `\nFIX THESE FAILING TESTS FIRST:\n${props.failingTests}` : ''}

## Implementation Approach

Assess whether TDD applies to this ticket. **Not all work needs new tests — don't write tests that test nothing meaningful.**

**TDD applies** when the ticket changes observable behavior:
- New features, public API surface, or code paths
- Bug fixes (test reproduces the bug first)
- Changed inputs, outputs, or error handling

**TDD does not apply** when the work is mechanical:
- Dead code removal, unused exports, deprecated aliases
- Renaming, moving, reorganizing without behavior change
- Mechanical refactoring (extract function, change visibility)
- Work where the compiler already enforces correctness

### When TDD Applies — Red → Green → Refactor

**Step 1: Write Failing Tests FIRST**

{props.testWritingGuidance && props.testWritingGuidance.length > 0
  ? props.testWritingGuidance.map(g => `${g}`).join('\n\n')
  : '- Write tests for happy paths AND error paths\n- Run test command to confirm tests FAIL (red phase)'}

**Step 2: Write Minimal Implementation (Green Phase)**

- Write the SMALLEST amount of code to make failing tests pass
{props.implementationGuidance && props.implementationGuidance.length > 0
  ? props.implementationGuidance.map(g => `- ${g}`).join('\n')
  : '- Follow project architectural patterns'}

**Step 3: Refactor**

- Clean up while keeping tests green
- Extract shared logic, improve naming
{props.formatterCommands && props.formatterCommands.length > 0
  ? `- Run formatters: ${props.formatterCommands.join(', ')}`
  : '- Run formatters'}

### When TDD Does Not Apply

1. Make the changes described in the plan
2. Run typecheck — no new type errors
{props.verifyCommands && props.verifyCommands.length > 0
  ? props.verifyCommands.map(c => `3. Run \`${c}\` — existing tests must still pass`).join('\n')
  : '3. Run existing tests — all suites must still pass'}
{props.formatterCommands && props.formatterCommands.length > 0
  ? `4. Run formatters: ${props.formatterCommands.join(', ')}`
  : '4. Run formatters'}

### Verify (both paths)

{props.verifyCommands && props.verifyCommands.length > 0
  ? props.verifyCommands.map(c => `- Run \`${c}\``).join('\n')
  : '- Run all test suites to verify'}

## Architecture Rules

{props.architectureRules && props.architectureRules.length > 0
  ? props.architectureRules.map(r => `- ${r}`).join('\n')
  : '- Follow the architectural patterns defined in the specs'}

## JJ COMMIT — MANDATORY (DO NOT SKIP)

You MUST commit and push your changes to the ticket branch before finishing. Uncommitted work is lost work.

1. `jj describe -m "{props.commitPrefix || 'EMOJI'} type(scope): description"` — describe your changes with a meaningful message.
2. `jj new` — create a new change for the next logical step. Repeat describe+new for each atomic change.
3. `jj bookmark set ticket/{props.ticketId} -r @`
4. `jj git push --bookmark ticket/{props.ticketId}`

{props.emojiPrefixes ? `Emoji prefixes: ${props.emojiPrefixes}` : 'Use conventional commit prefixes'}

**If you do not commit and push to the ticket branch, your work does not count. This is non-negotiable.**
