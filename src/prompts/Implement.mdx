IMPLEMENTATION PHASE — Unit: {props.unitId}

Title: {props.unitName}
Category: {props.unitCategory}

## Context

Read the plan file: {props.planFilePath}
Read the context file: {props.contextFilePath}

Implementation steps from plan:
{props.implementationSteps ? props.implementationSteps.map((s, i) => `${i + 1}. ${s}`).join('\n') : 'See plan file'}

{props.previousImplementation ? `\nPrevious implementation attempt:\nWhat was done: ${props.previousImplementation.whatWasDone}\nNext steps: ${props.previousImplementation.nextSteps ?? 'None specified'}` : ''}
{props.evictionContext ? `\nMerge queue eviction context from prior landing attempt (address this explicitly):\n${props.evictionContext}` : ''}

{props.reviewFeedback ? `\nReview feedback to address:\n${props.reviewFeedback}` : ''}

{props.failingTests ? `\nFIX THESE FAILING TESTS FIRST:\n${props.failingTests}` : ''}

{props.acceptanceCriteria && props.acceptanceCriteria.length > 0 ? `\n## Acceptance Criteria\n${props.acceptanceCriteria.map((a, i) => `${i + 1}. ${a}`).join('\n')}` : ''}

{props.depSummaries && props.depSummaries.length > 0 ? `\n## Dependency Context\nThese units completed before yours and their changes are on main:\n${props.depSummaries.map(d => `### ${d.id}\n${d.whatWasDone}\nFiles created: ${d.filesCreated.length > 0 ? d.filesCreated.join(', ') : 'none'}\nFiles modified: ${d.filesModified.length > 0 ? d.filesModified.join(', ') : 'none'}`).join('\n\n')}` : ''}

## Implementation Approach

Rule: **Implement a small ATOMIC UNIT** of work possible for ONE feature of the plan. For example, one module with related functionalities, one file, one test module, etc.
Don't aim to on _small_ units only: try to group into ONE reasonable work unit achievable in one commit. We'll re-iterate for each unit until completion.

### Step 0: Does this unit change observable behavior?

**TDD is mandatory** when the unit changes observable behavior:
- New features, public API surface, or code paths
- Bug fixes (test reproduces the bug first)
- Changed inputs, outputs, or error handling

**Skip TDD** only when the work is purely mechanical:
- Dead code removal, unused exports, deprecated aliases
- Renaming, moving, reorganizing without behavior change
- Mechanical refactoring (extract function, change visibility)
- Work where the compiler already enforces correctness

If in doubt, write the test. If you can't write a meaningful test, the work is mechanical.

### When TDD Applies — Red → Green → Refactor

**The Iron Law: NO PRODUCTION CODE WITHOUT A FAILING TEST FIRST.**

If you wrote code before the test, delete it. Start over. No exceptions — don't keep it as "reference", don't "adapt" it while writing tests, don't look at it. Delete means delete. Implement fresh from tests.

#### Step 1: RED — Write One Failing Test

Write a single test that describes the behavior you want. One behavior per test.

**What makes a good test:**
- Clear name describing expected behavior (e.g., `retries failed operations 3 times`)
- Tests real observable behavior, not implementation details
- Uses real code — mocks only when truly unavoidable (external services, network)
- Tests one thing

**What makes a BAD test — DO NOT WRITE THESE:**
- Testing types, type exports, or type narrowing — the compiler does this
- Testing that modules export the right names or re-exports exist
- Testing naming conventions, file structure, or package organization
- Vague test names (`it works`, `handles edge case`, `should be correct`)
- Tests that pass immediately — you're testing existing behavior or testing nothing

{props.testWritingGuidance && props.testWritingGuidance.length > 0
  ? props.testWritingGuidance.map(g => `${g}`).join('\n\n')
  : '- Write tests for happy paths AND error paths'}

**Run the test. Confirm it FAILS.**
- Must fail because the feature is missing (not syntax errors or typos)
- If it passes immediately: your test is wrong — you're testing existing behavior. Fix it or delete it.
- If it errors instead of failing: fix the error first, then confirm it fails correctly

#### Step 2: GREEN — Write Minimal Code

Write the SMALLEST amount of code to make the failing test pass.
- No additional features beyond what the test requires
- No "improvements" or "enhancements"
- No configurable options you don't need yet (YAGNI)
{props.implementationGuidance && props.implementationGuidance.length > 0
  ? props.implementationGuidance.map(g => `- ${g}`).join('\n')
  : '- Follow project architectural patterns'}

**Run the test. Confirm it PASSES.**
- If it fails: fix the code, not the test
- If other tests break: fix them now

**Repeat Steps 1-2 for each behavior the unit needs.**

#### Common Rationalizations — Don't Fall For These

| Excuse | Reality |
|--------|---------|
| "Too simple to test" | Simple code breaks. The test takes 30 seconds to write. |
| "I'll test after" | Tests that pass immediately prove nothing about your code. |
| "Already manually tested" | No record, can't re-run, doesn't prove edge cases. |
| "Keep as reference, write tests first" | You'll adapt it. That's testing-after. Delete means delete. |
| "Test is hard to write" | Hard to test = hard to use. Simplify the design. |

#### Red Flags — STOP and Start Over

If any of these happen, you skipped TDD. Delete code and restart:
- You wrote production code before writing a test
- A test passed immediately without new implementation
- You can't explain why a test failed
- You're rationalizing "just this once"

### When TDD Does Not Apply (Mechanical Work)

1. Make the changes described in the plan
2. Run typecheck — no new type errors
3. Run tests — ensuring we didn't break any existing tests
{props.verifyCommands && props.verifyCommands.length > 0 ? props.verifyCommands.map(c => `- Run \`${c}\` — existing tests must still pass`).join('\n') : '- Run existing tests — all suites must still pass'}
{props.formatterCommands && props.formatterCommands.length > 0 ? `- Run formatters: ${props.formatterCommands.join(', ')}` : '- Run formatters'}

### Verify (both paths)

{props.verifyCommands && props.verifyCommands.length > 0
  ? props.verifyCommands.map(c => `- Run \`${c}\``).join('\n')
  : '- Run all test suites to verify'}

## Architecture Rules

{props.architectureRules && props.architectureRules.length > 0
  ? props.architectureRules.map(r => `- ${r}`).join('\n')
  : '- Follow the architectural patterns defined in the specs'}

## JJ COMMIT — MANDATORY (DO NOT SKIP)

You MUST commit and push your changes to the ticket branch before finishing. Uncommitted work is lost work.

1. {`jj describe -m "${props.commitPrefix || "EMOJI"} type(scope): description"`} — describe your changes with a meaningful message.
2. `jj new` — create a new change for the next logical step. Repeat describe+new for each atomic change.
3. {`jj bookmark set ${props.branchPrefix || "unit/"}${props.unitId} -r @`}
4. {`jj git push --bookmark ${props.branchPrefix || "unit/"}${props.unitId}`}

{props.emojiPrefixes ? `Emoji prefixes: ${props.emojiPrefixes}` : 'Use conventional commit prefixes'}

**If you do not commit and push to the ticket branch, your work does not count. This is non-negotiable.**
